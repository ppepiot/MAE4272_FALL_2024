% This code calculates the theoretical power curve for a small-scale wind 
% turbine with a user-specified blade geometry 

% Clean up Matlab environment
clear all
close all


%% USER-SPECIFIED INPUT PARAMETERS 
% Free stream velocity
U1 = XXXX; % m/s

% Air Density
rho = XXXX; % kg/m3

% Desired RPM 
RPM = XXXX;

% Number of blades (fixed in this module)
n_blades = XXXX; 

% Number of airfoil sections used to discretize blade into blade elements
n = XXXX;

% Blade geometry:
% pitch (in degree) and chord (in meter) as a function of radial position)
geometry = readtable('Name_of_excel_file_containing_blade_geometry.xlsx');

% Lift and drag coefficients of chosen airfoil cross-section
airfoil_file = 'Name_of_excel_file_containing_airfoil_cl_cd.xlsx';
airfoil_name = 'Sheet1';

% Minimization function parameters
options = optimset('TolX',1e-10,'MaxFunEvals',10000000);
crit = 1e-3;

%% READ IN AND PROCESS USER PROVIDED DATA
% CL and CD data associated with airfoil used as blade cross-section
cl_cd_data = readtable(airfoil_file,'Sheet',airfoil_name);

% Blade dimensions (taken from geometry data)
R_root = geometry.r(1); % [m]
R_tip = geometry.r(length(geometry.r)); % [m]

% Convert RMP into rad/s
Omega = (RPM/60)*2*pi; 


%% DISCRETIZATION OF BLADE INTO SECTIONS (OR ELEMENTS)
% Create radial location of beginning and end of each airfoil section/blade element
r0 = linspace(R_root,R_tip,n+1);

% Allocate arrays for airfoil section spans and radial location (defined as mid-point)
dr = zeros(1,n);
r = zeros(1,n);

% Populate those arrays
for i=1:n
    % Span of each section
    dr(i) = r0(i+1)-r0(i);
    % Radial location of airfoil section (aka blade element)
    r(i) = (r0(i+1)+r0(i))/2; 
end


%% POWER CALCULATION

% Create arrays for torque and thrust as function of radial position
dT = zeros(1,n);
dQ = zeros(1,n);

% Create arrays to store a, aprime, and cost function as function of radial position
aval = zeros(1,n);
apval = zeros(1,n);
Fval = zeros(1,n);

alphaval = zeros(1,n);
clval = zeros(1,n);
cdval = zeros(1,n);

% Gather chords and pitches
chords = zeros(1,n);
pitches = zeros(1,n);
for i=1:n
    % Local chord at current radius
    chords(i) = interp1(geometry.r,geometry.chord,r(i),'spline');
    % Local pitch angle at current radius
    pitches(i) = interp1(geometry.r,geometry.pitch,r(i),'spline');
end
 

% --------------------------------------------------------- %

% Using fminsearch to find the proper a and aprime that make the momentum
% conservation equations compatible with airfoil theory in terms of
% thrust and torque generated by the flow at each location along the blade. 
% The cost function is defined as the relative difference in predicted thrust + 
% relative difference in predicted torque.

% Find optimal for each blade separately (assume that blade section do not 
% interact with one another). 
% Loop through each airfoil section
for i=1:n
    
    % Local chord at current radius
    chord = interp1(geometry.r,geometry.chord,r(i),'spline');
    
    % Local pitch angle at current radius
    pitch = interp1(geometry.r,geometry.pitch,r(i),'spline');
        
    % Initial guess for a and a prime: previous blade or 1/3 and 1/3 if first element
    % "as" is an array of 2 elements containing a as 1st element, a_prime
    % as second element. as0 is the initial guess for a and a_prime
    if i==1
        % Note that initial guess may in some circumstances (eg existence
        % of a saddle point in function) change the result of the
        % optimization. If there are issues handling the first blade
        % section, it may be worth trying other values for as0
        as0 = [1/3,0.0];
    else
        as0 = [aval(i-1),apval(i-1)];
    end
    
    % Find a and aprime that minimize cost function F
    [asmin, fval, exitflag] = fminsearch(@(as)getF(as(1),as(2),chord,pitch,r(i),dr(i),cl_cd_data,U1,rho,Omega,n_blades), as0, options);
    
    % Since this is an optimization process, it may be successful or not. 
    % If successful, fminsearch has found a minimum and returns an exit flag 
    % set to 1. If not successful, fminsearch could not find a minimum, and 
    % that exit flag is set to some other values (more details in fminsearch help
    if (exitflag ~= 1)
        fprintf('WARNING - DID NOT CONVERGE at radial location %f [%i]\n',r(i),i)
        fprintf('Minimization returned with exit flag value of %i\n', exitflag)
    end
   
    % Store values for a, aprime, and the actual cost function for plotting
    % purposes
    aval(i) = asmin(1);
    apval(i)= asmin(2);
    Fval(i) = fval;

    % Also storing angle of attack
    u = U1*(1-aval(i));
    w = Omega*r(i)*(1+apval(i));
    Urel = sqrt(u^2+w^2);
    phi = atan(u/w);
    alphaval(i) = rad2deg(phi) - pitch;
    clval(i) = interp1(cl_cd_data.alpha,cl_cd_data.cl,alphaval(i),'spline');
    cdval(i) = interp1(cl_cd_data.alpha,cl_cd_data.cd,alphaval(i),'spline');

    % Finding a minimum does not guarantee that we achieved what we wanted.
    % 1. a has to be less than 0.5, or else, the momentum conservation 
    % theory is not valid anyway.
    % 2. fval has to be small for both global conservation AND airfoil theory 
    % to be compatible.
    % If both conditions are satisfied this case, torque and thrust can be stored 
    % (evaluated from momentum theory, as both momentum and airfoil theories agree)
    if (fval < crit && aval(i)<1)
        dT(i) = rho * U1^2 * 4*aval(i)*(1-aval(i))*pi*r(i)*dr(i);
        dQ(i) = 4*apval(i)*(1-aval(i))*rho*U1*pi*Omega*r(i)^3*dr(i); 
    else

        % if fval is larger than the convergence criterion, the code found a minimum, but
        % that minimum does not lead to consistent and valid global conservation and 
        % airfoil models. We cannot use the results for any practical purpose.
        % Exit from the iterations and return a "MODEL CONVERGENCE FAILURE" message
        fprintf('MODEL CONVERGENCE FAILURE at radial location r=%f, STOPPING CALCULATION\n',r(i))
    
        % Diagnostics
        dTm = rho * U1^2 * 4*aval(i)*(1-aval(i))*pi*r(i)*dr(i);
        dQm = 4*apval(i)*(1-aval(i))*rho*U1*pi*Omega*r(i)^3*dr(i); 
        u = U1*(1-aval(i));
        w = Omega*r(i)*(1+apval(i));
        Urel = sqrt(u^2+w^2);
        phi = atan(u/w);
        alpha = phi - deg2rad(pitch);
        cl = interp1(cl_cd_data.alpha,cl_cd_data.cl,rad2deg(alpha),'spline');
        cd = interp1(cl_cd_data.alpha,cl_cd_data.cd,rad2deg(alpha),'spline');
        dFL = 1/2*rho*cd^2*cl*chord*dr(i);
        dFD = 1/2*rho*Urel^2*cd*chord*dr(i);
        dTa = n_blades * (dFL*cos(phi) + dFD*sin(phi));
        dQa = n_blades * (dFL*sin(phi) - dFD*cos(phi))*r(i);
        
        fprintf('fval %f\n dTa %f vs dTm %f [rel diff: %f]\n dQa %f vs dQm %f [rel diff: %f]\n',fval, dTa, dTm, 2*abs(dTa-dTm)/(abs(dTa)+abs(dTm)), dQa, dQm, 2*abs(dQa-dQm)/(abs(dQa)+abs(dQm))) 
        fprintf('alpha [deg]: %f\n cl: %f\n cd: %f\n',rad2deg(alpha), cl, cd)

        % Reset thrust and torque to zero everywhere
        dT = 0;
        dQ = 0;

        % Stop the code
        break;
    end

end

% Evaluate power for the given set of blades
P = sum(dQ)*Omega;

% Power coefficient: 1D theory shows that it cannot be larger than 16/27.
% Check the value of the power coefficient, aka normalized power.
Cp = P/(0.5*rho*pi*R_tip^2*U1^3);
    

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PLOTS AND DISPLAY OF RESULTS
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Print results in command window
fprintf('Total power extracted by 3-blade wind turbine: %d\n',P)
fprintf('Corresponding power coefficient Cp: %d\n',Cp)

% Plot Blade Geometry
figure
subplot(1,2,1)
plot(geometry.r,geometry.chord,'-')
title('Blade chord')
xlabel('Radius [m]')
ylabel('Chord [m]')

subplot(1,2,2)
plot(geometry.r,geometry.pitch,'-')
title('Blade pitch')
xlabel('Radius [m]')
ylabel('Pitch [deg]')

%% Plot Extra quantities to visualize what is going on
figure

subplot(2,4,1)
plot(r,clval)
title('Cl')
xlabel('Radius [m]')
ylabel('Cl [-]')

subplot(2,4,2)
plot(r,cdval)
title('Cd')
xlabel('Radius [m]')
ylabel('Cd [-]')

subplot(2,4,3)
plot(r,alphaval)
title('Angle of attack')
xlabel('Radius [m]')
ylabel('Alpha [deg]')

subplot(2,4,4)
plot(r,aval)
title('Axial induction factor')
xlabel('Radius [m]')
ylabel('a [-]')

subplot(2,4,5)
plot(r,apval)
title('Angular induction factor')
xlabel('Radius [m]')
ylabel('aprime [-]')

subplot(2,4,6)
plot(r,dT./dr)
title('Axial force')
xlabel('Radius [m]')
ylabel('Axial force per unit length')

subplot(2,4,7)
plot(r,dQ./(r.*dr))
title('Useful force')
xlabel('Radius [m]')
ylabel('Useful force per unit length')

subplot(2,4,8)
plot(r,Omega*dQ./dr)
title('Power')
xlabel('Radius [m]')
ylabel('Power per unit length')


function [F] = getF(a,aprime,chord,pitch,r,dr,cl_cd_data,U1,rho,Omega,n_blades)

    % Evaluate thrust/torque from momentum conservation
    if (a<0.4) 
        % Use 1D conservation of momentum/energy for small induction factor
        dTm = rho * U1^2 * 4*a*(1-a)*pi*r*dr;
    else
        % Glauert empirical relation to capture turbulent regime (a>0.4) 
        dTm = rho * U1^2 * (0.889-(0.0203-(a-0.143)^2)/0.6427) * pi*r*dr;
    end
    dQm = rho * U1 * 4*aprime*(1-a)*pi*Omega*r^3*dr;
    
    % Evaluate thrust/torque from airfoil theory
    % Velocity components
    u = U1*(1-a);
    w = Omega*r*(1+aprime);
    
    % Relative velocity
    Urel = sqrt(u^2+w^2);
    
    % Phi angle
    phi = atan(u/w);
    
    % Angle of attack
    alpha = phi - deg2rad(pitch);
    
    % Lift and drag coefficients
    cl = interp1(cl_cd_data.alpha,cl_cd_data.cl,rad2deg(alpha),'spline');
    cd = interp1(cl_cd_data.alpha,cl_cd_data.cd,rad2deg(alpha),'spline');
        
    % Lift and drag
    dFL = 1/2*rho*Urel^2*cl*chord*dr;
    dFD = 1/2*rho*Urel^2*cd*chord*dr;
    
    % Thrust
    dTa = n_blades * (dFL*cos(phi) + dFD*sin(phi));
    % Torque
    dQa = n_blades * (dFL*sin(phi) - dFD*cos(phi))*r;
    
    % Cost function (smooth, positive cost functions are typically easier
    % to handle during optimization)
    F = (dTa-dTm)^2+(dQa-dQm)^2;

end





